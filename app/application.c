#include <application.h>

// LED instance
bc_led_t led;

// Button instance
bc_button_t button;



static const uint8_t image_data_clear_sun[512] = {
    0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x3e, 0x00, 0xe0, 0x07, 0x00, 0x7c, 0x00,
    0x00, 0x7e, 0x00, 0xc0, 0x03, 0x00, 0x7e, 0x00,
    0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00,
    0x00, 0xfe, 0x01, 0x00, 0x00, 0x80, 0x7f, 0x00,
    0x00, 0xfe, 0x03, 0x00, 0x00, 0xc0, 0x7f, 0x00,
    0x00, 0xfc, 0x03, 0x00, 0x00, 0xc0, 0x3f, 0x00,
    0x00, 0xf8, 0x03, 0xfc, 0x3f, 0xc0, 0x1f, 0x00,
    0x00, 0xf0, 0x03, 0xff, 0xff, 0xc0, 0x0f, 0x00,
    0x00, 0xe0, 0xc3, 0xff, 0xff, 0xc3, 0x07, 0x00,
    0x00, 0x00, 0xe0, 0xff, 0xff, 0x07, 0x00, 0x00,
    0x00, 0x00, 0xf0, 0xff, 0xff, 0x0f, 0x00, 0x00,
    0x00, 0x00, 0xf8, 0x7f, 0xfe, 0x1f, 0x00, 0x00,
    0x00, 0x00, 0xfc, 0x07, 0xe0, 0x3f, 0x00, 0x00,
    0x00, 0x00, 0xfe, 0x03, 0xc0, 0x7f, 0x00, 0x00,
    0x00, 0x00, 0xfe, 0x00, 0x00, 0x7f, 0x00, 0x00,
    0x00, 0x00, 0x7f, 0x00, 0x00, 0xfe, 0x00, 0x00,
    0x00, 0x00, 0x7f, 0x00, 0x00, 0xfe, 0x00, 0x00,
    0x00, 0x80, 0x3f, 0x00, 0x00, 0xfc, 0x01, 0x00,
    0x00, 0x80, 0x1f, 0x00, 0x00, 0xf8, 0x01, 0x00,
    0x00, 0x80, 0x1f, 0x00, 0x00, 0xf8, 0x01, 0x00,
    0xfc, 0x83, 0x1f, 0x00, 0x00, 0xf8, 0xc1, 0x3f,
    0xfe, 0x87, 0x1f, 0x00, 0x00, 0xf8, 0xe1, 0x7f,
    0xff, 0x87, 0x1f, 0x00, 0x00, 0xf8, 0xe1, 0xff,
    0xff, 0x87, 0x1f, 0x00, 0x00, 0xf8, 0xe1, 0xff,
    0xfe, 0x87, 0x1f, 0x00, 0x00, 0xf8, 0xe1, 0x7f,
    0xfc, 0x83, 0x1f, 0x00, 0x00, 0xf8, 0xc1, 0x3f,
    0x00, 0x80, 0x1f, 0x00, 0x00, 0xf8, 0x01, 0x00,
    0x00, 0x80, 0x1f, 0x00, 0x00, 0xf8, 0x01, 0x00,
    0x00, 0x80, 0x3f, 0x00, 0x00, 0xfc, 0x01, 0x00,
    0x00, 0x00, 0x7f, 0x00, 0x00, 0xfe, 0x00, 0x00,
    0x00, 0x00, 0x7f, 0x00, 0x00, 0xfe, 0x00, 0x00,
    0x00, 0x00, 0xfe, 0x00, 0x00, 0x7f, 0x00, 0x00,
    0x00, 0x00, 0xfe, 0x03, 0xc0, 0x7f, 0x00, 0x00,
    0x00, 0x00, 0xfc, 0x07, 0xe0, 0x3f, 0x00, 0x00,
    0x00, 0x00, 0xf8, 0xff, 0xff, 0x1f, 0x00, 0x00,
    0x00, 0x00, 0xf0, 0xff, 0xff, 0x0f, 0x00, 0x00,
    0x00, 0x00, 0xe0, 0xff, 0xff, 0x07, 0x00, 0x00,
    0x00, 0xe0, 0xc3, 0xff, 0xff, 0xc3, 0x07, 0x00,
    0x00, 0xf0, 0x03, 0xff, 0xff, 0xc0, 0x0f, 0x00,
    0x00, 0xf8, 0x03, 0xfc, 0x3f, 0xc0, 0x1f, 0x00,
    0x00, 0xfc, 0x03, 0x00, 0x00, 0xc0, 0x3f, 0x00,
    0x00, 0xfe, 0x03, 0x00, 0x00, 0xc0, 0x7f, 0x00,
    0x00, 0xfe, 0x01, 0x00, 0x00, 0x80, 0x7f, 0x00,
    0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00,
    0x00, 0x7e, 0x00, 0xc0, 0x03, 0x00, 0x7e, 0x00,
    0x00, 0x3e, 0x00, 0xe0, 0x07, 0x00, 0x7c, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00
};
const bc_image_t clear_sun = { image_data_clear_sun, 64, 64, 8 };

void button_event_handler(bc_button_t *self, bc_button_event_t event, void *event_param)
{
    if (event == BC_BUTTON_EVENT_PRESS)
    {
        bc_led_set_mode(&led, BC_LED_MODE_TOGGLE);
    }

    // Logging in action
    bc_log_info("Button event handler - event: %i", event);
}

uint8_t fifo_get_last_byte(bc_fifo_t *fifo)
{
    uint8_t *ptr = (uint8_t *) fifo->buffer + fifo->head;

    // Decrement one position to get the latest byte in FIFO
    ptr--;

    // Wrap around pointer in cse of underflow
    if (ptr < (uint8_t*)fifo->buffer)
    {
        ptr += fifo->size;
    }

    return *ptr;

}

bc_fifo_t tx_fifo;
bc_fifo_t rx_fifo;
uint8_t tx_fifo_buffer[64];
uint8_t rx_fifo_buffer[4096];

uint8_t rx_framebuffer[4096];

uint8_t lcd_framebuffer[2048];

void uart_handler(bc_uart_channel_t channel, bc_uart_event_t event, void *param)
{

    if (event == BC_UART_EVENT_ASYNC_WRITE_DONE)
    {
        // here you can for example send more data
    }
    if (event == BC_UART_EVENT_ASYNC_READ_DATA)
    {
        uint8_t last_byte = fifo_get_last_byte(&rx_fifo);
        if (last_byte  == 0x0D)
        {
            // Read data from FIFO by a single byte as you receive it
            size_t number_of_rx_bytes = bc_uart_async_read(BC_UART_UART2, rx_framebuffer, sizeof(rx_framebuffer));
            char uart_tx[32];


            // decode, minus 1 byte CR
            size_t output_len = sizeof(lcd_framebuffer);
            volatile bool ret = bc_base64_decode(lcd_framebuffer, &output_len, (char*)rx_framebuffer, number_of_rx_bytes - 1);

            snprintf(uart_tx, sizeof(uart_tx), "RX: %d, b64_ok: %d\r\n", number_of_rx_bytes, ret);
            bc_uart_async_write(BC_UART_UART2, uart_tx, strlen(uart_tx));

            bc_image_t img;
            img.data = lcd_framebuffer;
            img.width = 128;
            img.height = 128;

            bc_module_lcd_clear();

            bc_module_lcd_draw_image(0, 0, &img);

            bc_module_lcd_update();
        }
    }
    if (event == BC_UART_EVENT_ASYNC_READ_TIMEOUT)
    {
        // No data received during set timeout period
        //char uart_tx[] = "Timeout\r\n";
        //bc_uart_async_write(BC_UART_UART2, uart_tx, strlen(uart_tx));
        // You can also read received bytes here instead of BC_UART_EVENT_ASYNC_READ_DATA
    }
}

void application_init(void)
{
    bc_system_pll_enable();

    // Initialize logging
    bc_log_init(BC_LOG_LEVEL_DUMP, BC_LOG_TIMESTAMP_ABS);

    // Initialize LED
    bc_led_init(&led, BC_GPIO_LED, false, false);
    bc_led_set_mode(&led, BC_LED_MODE_ON);

    // Initialize button
    bc_button_init(&button, BC_GPIO_BUTTON, BC_GPIO_PULL_DOWN, false);
    bc_button_set_event_handler(&button, button_event_handler, NULL);

    // Initialize LCD
    // The parameter is internal buffer in SDK, no need to define it
    bc_module_lcd_init();

    // Init default font, this is necessary
    // See other fonts in sdk/bcl/inc/bc_font_common.h
    bc_module_lcd_set_font(&bc_font_ubuntu_15);

    // Draw string at X, Y location
    bc_module_lcd_draw_string(10, 5, "Hello world!", true);

    bc_module_lcd_draw_line(5, 20, 115, 20, true);

    // Use big font
    bc_module_lcd_set_font(&bc_font_ubuntu_24);
    bc_module_lcd_draw_string(10, 40, "Big", true);

    // Set back default font
    bc_module_lcd_set_font(&bc_font_ubuntu_15);
    bc_module_lcd_draw_string(60, 50, "world", true);

    bc_module_lcd_draw_line(10, 65, 100, 75, true);

    bc_module_lcd_draw_image(20, 20, &clear_sun);

    // Don't forget to update
    bc_module_lcd_update();


    bc_uart_init(BC_UART_UART2, BC_UART_BAUDRATE_921600, BC_UART_SETTING_8N1);
    bc_uart_set_event_handler(BC_UART_UART2, uart_handler, NULL);

    bc_fifo_init(&tx_fifo, tx_fifo_buffer, sizeof(tx_fifo_buffer));
    bc_fifo_init(&rx_fifo, rx_fifo_buffer, sizeof(rx_fifo_buffer));

    bc_uart_set_async_fifo(BC_UART_UART2, &tx_fifo, &rx_fifo);

    bc_uart_async_read_start(BC_UART_UART2, 500);
}
/*
void application_task(void)
{
    // Logging in action
    bc_log_debug("application_task run");

    // Plan next run this function after 1000 ms
    bc_scheduler_plan_current_from_now(1000);
}*/
